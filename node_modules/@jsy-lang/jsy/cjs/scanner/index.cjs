'use strict';

const SourceLocation ={
  __proto__: null

, get [Symbol.toStringTag]() {return '«SourceLocation»'}
, toString() {return `«${this.line}:${this.column}»`}
, get column() {return this.pos - this.line_pos}

, create(source, file) {
    const root ={
      line:0, pos:0, line_pos:0
    , __proto__: SourceLocation};

    if (null != file) {
      root.file = file;}

    Object.defineProperties(root,{
      __root__:{value: root}
    , source:{value: source} } );
    return Object.freeze(root) }

, nextLine() {
    let {line, pos} = this;
    line += 1;
    return Object.freeze({
      line, pos, line_pos: pos,
      __proto__: this.__root__}) }

, move(char_len) {
    if ('string' === typeof char_len) {
      char_len = char_len.length;}
    else if ('number' === typeof char_len) {
      char_len |= 0;}
    else throw new TypeError('Expected move to be a string or number')

    let {line, pos, line_pos} = this;
    pos += char_len;
    return Object.freeze({
      line, pos, line_pos,
      __proto__: this.__root__}) }

, distance(other) {
    const lines = this.line - other.line;
    const chars = this.pos - other.pos;
    return {lines, chars} }

, slice(other) {
    if (this.source !== other.source) {
      throw new Error(`Locations from different sources`) }
    return this.source.slice(this.pos, other.pos) }

, syntaxError(message) {
    const err = new SyntaxError(message);
    err.src_loc = this;
    return err} };

var createLoc = SourceLocation.create;

const rx_lines = /(\r\n|\r|\n)/ ;
const rx_indent = /^([ \t]*)(.*)$/ ;
const rx_indent_order = /^[\t]*[ ]*$/ ;

function basic_offside_scanner(source, feedback) {
  if (null == feedback) {
    feedback ={
      warn(msg, ...args) {console.warn(`[Offside Warning]:: ${msg}`, ...args);} }; }

  const all_lines = [];
  const q_raw_lines = source.split(rx_lines);

  const offside_line_proto ={
    __proto__: null
  , get source() {
      const {start, end} = this.loc;
      return start.slice(end)} };

  let loc_tip = createLoc(source, feedback.file);

  while (0 !== q_raw_lines.length) {
    const loc ={start: loc_tip = loc_tip.nextLine()};

    const src_line = q_raw_lines.shift() || '';
    loc.end = loc_tip = loc_tip.move(src_line);

    const src_line_end = q_raw_lines.shift() || '';
    loc_tip = loc_tip.move(src_line_end);


    const match = rx_indent.exec(src_line);
    const loc_indent = loc.start.move(match[1]);
    const is_blank = 0 === match[2].length;

    if (! rx_indent_order.test(match[1])) {
      throw loc.start.syntaxError(`Mixed tab and space indent (${loc_indent})`, ) }

    const raw ={
      line: src_line
    , line_end: src_line_end
    , indent: match[1]
    , content: match[2]};

    let node;
    if (is_blank) {
      node ={
        type: 'offside_blank_line', loc
      , is_blank}; }

    else {
      const indent_node ={
        type: 'offside_indent',
        loc:{
          start: loc.start
        , end: loc_indent}
      , len_indent: match[1].length
      , indent: match[1]};

      const conent_node ={
        type: 'offside_content',
        loc:{
          start: loc_indent
        , end: loc.end}
      , len_indent: match[1].length
      , indent: match[1]
      , content: match[2]};

      node ={
        __proto__: offside_line_proto
      , type: 'offside_line', loc
      , indent: indent_node
      , content: conent_node
      , len_indent: match[1].length}; }

    Object.defineProperties(node,{raw: {value: raw}});
    all_lines.push(node); }

  add_indent_info(all_lines);
  return all_lines}


function add_indent_info(all_lines) {
  let len_dedent = 0; // how far to dedent to next outer level
  let len_stack = [0];
  // work backwards from the file end
  for (let i = all_lines.length-1 ; i>=0 ; i--) {
    let ln = all_lines[i];
    if (ln.is_blank) {continue}

    ln.len_dedent = len_dedent;

    // how many indent prefix chars per line
    let len_indent = ln.len_indent;

    let len_inner;
    while (len_stack[0] > len_indent) {
      len_inner = len_stack.shift();}

    if (len_stack[0] < len_indent) {
      // len_indent is the new stack tip
      len_stack.unshift(len_indent); }

    if (len_inner) {
      ln.len_inner = len_inner;}

    len_dedent = len_indent;} }

function ensure_indent(ctx, scanner) {
  const ln_first = scanner.ln_first;
  if (undefined === ln_first) {return true}
  const len_first_indent = ln_first.len_indent;

  const d_dedent = ctx.ln.len_indent - len_first_indent;
  if (d_dedent < 0) {
    throw ctx.ln.indent.loc.end.syntaxError(
`Invalid indent level in ${scanner.description}. (${ctx.ln.indent.loc.end})  --  current indent: ${ctx.ln.len_indent}  start indent: ${len_first_indent} from (${ln_first.loc.start})`) }
  else return true}


function ensure_progress(loc0, loc1) {
  if (loc0.pos == loc1.pos) {
    throw new Error(`Scanner failed to make progress (${loc1})`) }

  if (loc0.pos > loc1.pos) {
    throw new Error(`Scanner went backward (${loc1} from ${loc0})`) } }


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class DispatchScanner {
  constructor(disp_name) {
    this.disp_name = disp_name || 'root';
    this.by_kind = {};
    this.by_op = {};}

  startCompile() {
    Object.defineProperties(this,{
      rx_list:{value: (this.rx_list || []).slice()} } );
    this.by_kind = Object.assign({}, this.by_kind);
    this.by_op = Object.assign({}, this.by_op);
    return this}

  addScannerList(scannerList) {
    for (const scanner of scannerList) {
      if (scanner) {
        this.addScanner(scanner);} }
    return this}

  addScanner(scanner) {
    if (scanner.withDispatch) {
      scanner = scanner.withDispatch(this);}

    if (scanner.is_body) {
      this.ds_body = scanner;}

    this.by_op[scanner.op] = scanner;}

  addRegExpScanner(scanner, kind, re_disp) {
    if (kind) {
      this.by_kind[kind] = scanner.op;
      this.rx_list.push(new RegExp(re_disp, 'g')); }
    return this}

  finishCompile(ds_body) {
    if (undefined === ds_body) {
      ds_body = this.ds_body;}
    return Object.defineProperties(this,{
      ds_body:{value: ds_body, writable: true} } ) }


  clone0() {
    if (undefined !== this.level) {
      throw new Error(`Invalid clone0`) }
    return this.cloneWithScanner()}

  cloneWithScanner(...scanners) {
    return this.cloneWithScannerList(scanners)}
  cloneWithScannerList(scanners) {
    const self = Object.create(this);
    self.level = 1 + 0|self.level;
    self.description = self.description.replace(
      /\(\d+\)/, `(${self.level})`);

    self.startCompile();
    self.addScannerList(scanners);
    self.finishCompile();
    return self}


  get_active_dispatch(ctx) {
    return ctx[`dispatch_${this.disp_name}`]}
  set_active_dispatch(ctx) {
    ctx.dispatch = ctx[`dispatch_${this.disp_name}`] = this;}


  newline(ctx, is_blank) {}

  scan(ctx, idx0) {
    const loc0 = ctx.loc_tip;
    const res = this._scan(ctx, idx0);
    ensure_progress(loc0, ctx.loc_tip);
    return res}

  _scan(ctx, idx0) {
    this.set_active_dispatch(ctx);

    if (undefined === this.ln_first) {
      if (undefined === this.level) {
        throw new Error('Scanner with level: undefined')}

      this.ln_first = ctx.ln;}

    ensure_indent(ctx, this);

    const source = ctx.ln_source; // slice is done by setting lastIndex
    let match=null, idx1 = Infinity;

    for (const rx of this.rx_list) {
      rx.lastIndex = idx0; // regexp powered source.slice()

      const m = rx.exec(source);
      if (null !== m && m.index < idx1) {
        idx1 = m.index;
        match = m;} }

    if (null === match) {
      return this.ds_body.scan(ctx, idx0)}

    if (idx0 !== idx1) {
      return this.ds_body.scan_fragment(
        ctx, source.slice(idx0, idx1)) }

    const kind = match.filter(Boolean)[1];
    const op = this.by_kind[kind];
    const op_scanner = this.by_op[op];
    if (! op_scanner) {
      throw new Error(`No scanner registered for « ${kind} »`) }

    return op_scanner.scan(ctx, idx1)}

  scan_fragment(ctx, content) {
    throw new Error(`${this.description} does not support fragments`) } }


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class DispatchFirstlineScanner extends DispatchScanner {
  clone0() {
    const self = super.clone0();
    self.ds_body = self.ds_body.clone0();
    return self}
  scan(ctx, idx0) {
    ctx.scanner = this.ds_body;
    return super.scan(ctx, idx0)} }


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class BaseSourceScanner {
  constructor(options) {
    Object.assign(this, options);
    this._compileForInit();}

  _compileForInit() {}

  withDispatch(ds) {return this}

  emit_ast(ctx, content, ast_type) {
    const start = ctx.loc_tip;
    const end = ctx.loc_tip = start.move(content || 0);
    const ast ={type: ast_type || this.op, loc: {start, end}, content};
    this.ast_extend(ctx, ast);
    ctx.parts.push(ast);
    return ast}

  ast_extend(ctx, ast) {}

  newline(ctx, is_blank) {}
  scan_fragment(ctx, content) {
    throw new Error(`Scanner (${this.description}) does not support fragments`) }
  scan(ctx, idx0) {
    throw new Error(`Scanner (${this.description}) does not support scans`) } }


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class SourceCodeScanner extends BaseSourceScanner {
  get is_body() {return true}

  scan_fragment(ctx, content) {
    this.scan_content(ctx, content); }

  scan(ctx, idx0) {
    this.scan_content(ctx, ctx.ln_source.slice(idx0)); }

  scan_content(ctx, content) {
    if (content) {
      this.emit_ast(ctx, content); } } }


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class NestedCodeScanner extends SourceCodeScanner {
  constructor(options) {
    super(options);
    if (! this.char_pairs) {
      throw new Error('Missing required char_pairs mapping') }

    const chars = Object.keys(this.char_pairs).join('\\');
    this.rx = new RegExp(`([${chars}])`);}

  withOuter(options) {
    const scanner = options.scanner;
    if ('function' !== typeof scanner.scan) {
      throw new Error(`Expected valid outer scanner`) }
    delete options.scanner;

    const self = Object.create(this,{
      restore_scanner:{value: scanner} } );
    Object.assign(self, options);
    return self}

  scan_content(ctx, nested_content) {
    const {stack, char_pairs} = this;

    let content = '';
    for (const tok of nested_content.split(this.rx)) {
      const p = 1 === tok.length ? char_pairs[tok] : undefined;

      if (undefined === p) {
        content += tok;
        continue}

      if (true === p) {
        content += tok;
        stack.push(tok);
        continue}

      const tip = stack.pop();
      if (tip !== p) {
        const loc = ctx.loc_tip.move(content);
        throw loc.syntaxError(
    `Mismatched nesting in ${this.description} (${loc})`) }

      if (0 !== stack.length) {
        content += tok;
        continue}

      if (content) {
        this.emit_ast(ctx, content); }
      this.emit_ast(ctx, tok, this.ast_end || 'nested_end');
      ctx.scanner = this.restore_scanner;
      return}

    // all tokens with non-zero stack
    if (content) {
      this.emit_ast(ctx, content); } } }


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class RegExpScanner extends BaseSourceScanner {

  _compileForInit() {
    const {rx_open, rx_close} = this;
    const rx_disp = new RegExp(
      (rx_open ? rx_open.source : '') + rx_close.source);

    const rx_resume = new RegExp(
      '^' + rx_close.source);

    Object.defineProperties(this,{
      rx_disp:{value: rx_disp}
    , rx_resume:{value: rx_resume} } ); }

  withDispatch(ds) {
    this.compileForDispatch(ds);
    return this}

  compileForDispatch(ds) {
    if (undefined === this.kind) {return}

    const match = this.rx_disp.exec(this.example);
    if (null === match || this.kind !== match[1] || null == match[2]) {
      throw new Error(`Invalid scanner regexp and/or example (${this.description})`) }

    ds.addRegExpScanner(this, this.kind, this.rx_disp.source); }



  newline(ctx, is_blank) {
    if (! this.multiline && ! this.allow_blank_close) {
      throw ctx.ln.loc.end.syntaxError(
  `Newline in ${this.description} (${ctx.ln.loc.end})`) } }

  ast_extend(ctx, ast) {
    const ln = this.ln_first || ctx.ln;
    if (undefined !== ln.len_inner) {
      ast.block_indent = ln.len_inner;}
    return ast}

  scan(ctx, idx0) {
    const match = this.rx_disp.exec(ctx.ln_source.slice(idx0));
    if (null === match) {
      throw ctx.loc_tip.syntaxError(
  `Invalid scan ${this.description}. (${ctx.loc_tip})`) }

    const [content, open, close] = match;

    const t_content = this.nestTrim(content, close, false);
    if (null != t_content) {
      this.ast_scan_match({open, close},
        this.emit_ast(ctx, t_content,) ); }
    return this.post_scan(ctx, close)}

  scan_continue(ctx, idx0) {
    ensure_indent(ctx, this);

    const match = this.rx_resume.exec(ctx.ln_source.slice(idx0));
    if (null === match) {
      throw ctx.loc_tip.syntaxError(
  `Invalid scan continue ${this.description}. (${ctx.loc_tip})`) }

    const [content, close] = match;

    const t_content = this.nestTrim(content, close, true);
    if (null != t_content) {
      this.ast_scan_match({close},
        this.emit_ast(ctx, t_content,) ); }
    return this.post_scan(ctx, close)}

  ast_scan_match(match, ast) {}

  nestTrim(content, close, isContinue) {return content}

  post_scan(ctx, close) {
    if (! close) {
      if (this.invert_close) {
        // e.g. no '\' continuations at end of line
        return true}

      if (! this.allow_blank_close) {
        ctx.scanner = this.continueScanner(ctx);}
      return}

    else if (this.invert_close) {
      // e.g. '\' continuations at end of line
      ctx.scanner = this.continueScanner(ctx);}

    return this.nestMatch(close,
      ctx, this.hostScanner || this) }

  nestMatch(close, ctx, hostScanner) {
    const nesting = this.nesting;
    if (undefined !== nesting) {
      return this.nestWith(
        nesting[close],
        ctx, hostScanner) }
    return true }// pop ctx.scanner

  nestWith(nested, ctx, hostScanner) {
    if (true === nested || undefined === nested || null === nested) {
      return true }// pop ctx.scanner

    else if (hostScanner === nested || 'host' === nested) {
      ctx.scanner = hostScanner.continueScanner(ctx);
      return}

    else if ('function' === typeof nested.nestedScanner) {
      ctx.scanner = nested.nestedScanner(ctx);
      return}

    else if ('function' === typeof nested) {
      return nested(ctx, hostScanner) }

    return nested}


  nestedScanner(ctx) {
    return this._asNestedScanner(ctx, 'nest',{} ) }

  continueScanner(ctx) {
    return this._asNestedScanner(ctx, 'cont',{
      op: this.op_continue || this.op
    , continueScanner(ctx) {return this}
    , scan(ctx, idx0) {
        this.scan_continue(ctx, idx0);} } ) }

  _asNestedScanner(ctx, desc, body) {
    const restore_scanner = ctx.scanner;
    const self ={
      __proto__: this
    , description: `${this.description} (${desc})`
    , ln_first: ctx.ln_first || ctx.ln

    , _pop_scanner(ctx) {
        if (this.op_pop) {
          this.emit_ast(ctx, '', this.op_pop); }
        ctx.scanner = restore_scanner;}

    , scan(ctx, idx0) {
        if (true === super.scan(ctx, idx0)) {
          this._pop_scanner(ctx);} }

    , scan_continue(ctx, idx0) {
        if (true === super.scan_continue(ctx, idx0)) {
          this._pop_scanner(ctx);} } };

    return Object.assign(self, body) } }


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class MultiLineScanner extends RegExpScanner {
  newline(ctx, is_blank) {}
  get multiline() {return true}

  ast_extend(ctx, ast) {
    //let ln = this.ln_first || ctx.ln
    let col = ast.loc.start.column;
    let mlctx = this.mlctx ??= {col};

    if (col < mlctx.col) {
      mlctx.col = col;}

    ast.mlctx = mlctx;
    return ast} }

function bind_context_scanner(context_scanners) {
  if (! Object.isFrozen(context_scanners) || ! Array.isArray(context_scanners)) {
    throw new TypeError(`Expected a frozen array of context scanners`) }

  const cache = bind_context_scanner.cache || new WeakMap();
  if (cache !== bind_context_scanner.cache) {
    bind_context_scanner.cache = cache;}

  let res = cache.get(context_scanners);
  if (undefined === res) {
    res = compile_context_scanner(context_scanners);
    cache.set(context_scanners, res);}
  return res}


function compile_context_scanner(context_scanners) {
  const ds_first = build_composite_scanner();
  return context_scanner

  function context_scanner(offside_lines) {
    const ctx ={scanner: ds_first.clone0()};

    for (const ln of offside_lines) {
      if (ln.is_blank) {
        delete ln.content;
        ctx.scanner.newline(ctx, true);
        continue}


      ctx.parts = [];
      ctx.ln = ln;

      scan_source(ctx, ln.content);

      if (0 === ctx.parts.length) {
        throw new Error(`No parts generated by context scanner`) }

      ln.content = ctx.parts;
      ctx.scanner.newline(ctx, false);}

    ctx.scanner.newline(ctx, true);
    return offside_lines}


  function scan_source(ctx, ln_content) {
    const ln_source = ctx.ln_source = ln_content.content;
    const loc_start = ctx.loc_tip = ctx.loc_start = ln_content.loc.start;
    const pos0 = loc_start.pos;

    while (true) {
      const idx0 = ctx.loc_tip.pos - pos0;
      if (idx0 >= ln_source.length) {
        return }// done with this line

      ctx.scanner.scan(ctx, idx0); } }


  function build_composite_scanner() {
    const ds_body = new DispatchScanner().startCompile();
    ds_body.description = 'JSY Dispatch scanner (0)';
    const ds_first = new DispatchFirstlineScanner().startCompile();
    ds_first.description = 'Firstline JSY Dispatch scanner (0)';

    for (const scanner of context_scanners) {
      if (! scanner) {continue}

      const ds = scanner.firstline ? ds_first : ds_body;
      ds.addScanner(scanner);}

    ds_body.finishCompile();
    return ds_first.finishCompile(ds_body)} }

function scan_offside_contexts(source, feedback, disp_name, context_scanners) {
  // see scan_javascript and scan_clike for good context_scanners
  const context_scanner = bind_context_scanner(disp_name);
  return context_scanner(basic_offside_scanner(source, feedback)) }

function inject_dedent(offside_lines, trailing_types) {
  if ('function' !== typeof trailing_types) {
    const s_trailing_types = new Set(
      trailing_types || ['comment_eol']);
    trailing_types = k => s_trailing_types.has(k);}

  for (const ln of offside_lines) {
    if (ln.is_blank) {continue}

    const {len_dedent, len_indent, len_inner} = ln;

    const offside_dedent ={
      type: 'offside_dedent'
    , len_dedent, len_indent};

    if (len_inner) {
      offside_dedent.len_inner = len_inner;}

    const last = ln.content.pop();
    if (last.multiline || trailing_types(last.type)) {
      ln.content.push(offside_dedent, last); }
    else {
      ln.content.push(last, offside_dedent); } } }

const scanner_source =
  new SourceCodeScanner({
      description: 'Source Code Scanner'
    , op: 'src'});

const scanner_nestedSrc =
  new NestedCodeScanner({
    op: 'src', description: 'Template parameter source'
  , char_pairs:{
      '{': true, '}': '{'
    , '(': true, ')': '('
    , '[': true, ']': '['} });

const scanner_hashbangDirective =
  new RegExpScanner({
      description: 'Hashbang directive'
    , example: '#!/usr/bin/env node'
    , op: 'hashbang', kind:'#!'
    , rx_open: /^(#!)/, rx_close: /.*($)/,
      firstline: true
    , allow_blank_close: true});

const scanner_commentEOL =
  new RegExpScanner({
      description: 'Comment to end of line'
    , example: '// comment'
    , op: 'comment_eol', kind:'//'
    , rx_open: /(\/\/)/, rx_close: /.*($)/,
      allow_blank_close: true});

const scanner_commentMultiLine =
  new MultiLineScanner({
      description: 'Multi-line comment'
    , example: '/* comment */'
    , op: 'comment_multi', kind:'/*'
    , rx_open: /(\/\*)/, rx_close: /.*?(\*\/|$)/,});

const scanner_strSingle =
  new RegExpScanner({
      description: 'Single quote string literal'
    , example: "'single quote'"
    , op: 'str1', kind:"'"
    , rx_open: /(')/, rx_close: /(?:\\.|[^'])*('|$)/,});

const scanner_strDouble =
  new RegExpScanner({
      description: 'Double quote string literal'
    , example: '"double quote"'
    , op: 'str2', kind:'"'
    , rx_open: /(")/, rx_close: /(?:\\.|[^"])*("|$)/,});

const scanner_preprocessor =
  new RegExpScanner({
      description: 'Preprocessor directive'
    , example: '# IF platform === "web"'
    , op: 'preprocessor', kind:'#'
    , rx_open: /^\s*(#)/, rx_close: /.*?([\\]?)\s*$/,
      invert_close: true // preprocessor uses '\' continuations
    , allow_blank_close: true});


const clike_context_scanners = Object.freeze([
  scanner_source
, scanner_hashbangDirective
, scanner_commentEOL
, scanner_commentMultiLine
, scanner_strSingle
, scanner_strDouble
, scanner_preprocessor]);


function scan_clike(source, feedback) {
  return scan_offside_contexts(source, feedback, clike_context_scanners)}

const scanner_regexp =
  new RegExpScanner({
      description: 'RegExp literal'
    , example: '/regexp/'
    , op: 'regexp'
    , kind: '/'

    , /*
      rx_open: rx_or_parts @:
        opts: @[]
          /(\/)(?![\/\*])/    // start of a potential regexp literal, but not a comment

          @{}                 // ...complex regexp grammar...
            pre: ''
            opts: @[]
              /\\./           // ...any escaped character...
              /[^\\\/\[]/     // ...or any non-special character...

              @{}             // ... or a bracket [] expression...
                pre: '\\['        // started with a '[' character
                opts: @[]
                  /\\./           // ...with any escaped character
                  /[^\]]/         // ...or any non-escaped non-ending ']' character
                post: '*\\]'      // ended with an ending ']' character

            post: '+'         // one or more interior expressions

          /(?=\/)/            // (lookahead) end of a regexp literal
      */

      rx_open: new RegExp(
        /(\/)(?![\/\*])/ .source + // a RegExp start but not a comment
        /(?:\\.|[^\\\/\[]|\[(?:\\.|[^\]])*\])+/ .source)

    , rx_close: /(\/[a-z]*)\s*(?=[;.,)\]}]|$)/  // inspired by vim's syntax highlighting end

    , });//multiline: false // spec https://tc39.es/ecma262/#sec-literals-regular-expression-literals


const scanner_strTemplate =
  new MultiLineScanner({
      description: 'Template quote string literal'
    , example: '`template string`'
    , op: 'str_template'
    , kind: '`'
    , rx_open: /(`)\\?/
    , rx_close: /(?:\\.|\$(?!{)|[^\$`\\])*(`|\${|$)/
    , nesting:{
        '${': templateArgNesting}

    , ast_scan_match(scan, ast) {
        if ('`' == scan.open) {
          ast.tmpl_opened = true;}
        if ('`' == scan.close) {
          ast.tmpl_closed = true;} } });

function templateArgNesting(ctx, hostScanner) {
  const src = scanner_nestedSrc.withOuter({
    scanner: hostScanner.continueScanner(ctx)
  , stack:['{' ]// from the template parameter opening
  , ast_end: 'template_param_end'});

  src.emit_ast(ctx, '', 'template_param');

  ctx.scanner = ctx.dispatch_root.cloneWithScanner(src);}



const js_context_scanners = Object.freeze([
  scanner_regexp
, scanner_strTemplate
, ... clike_context_scanners]);

function scan_javascript(source, feedback) {
  return scan_offside_contexts(source, feedback, js_context_scanners)}

const _as_loc = p => p.loc &&= `${p.loc.start}..${p.loc.end}`;

function * iter_ast_ndjson(iter_ast) {
  for (let ln of iter_ast) {
    _as_loc(ln);
    if (ln.indent) {
      _as_loc(ln.indent);}

    ln.content?.map?.(_as_loc);
    yield ln;} }


function ast_to_json5(ast) {
  const out = [];
  for (let ln of ast) {
    if (loc) {loc = loc.start.toString();}
    if (! content) {
      out.push(`  ["${type} at ${loc}"],`);
      continue}

    out.push(`  ["${type} at ${loc} with '${indent.indent}'",`);

    for (let {type:ct, content:cc} of content) {
      out.push(`    ${JSON.stringify([ct, cc])},`); }

    out.push(`  ],\n`); }

  return `[\n${out.join('\n')}\n]\n`}

exports.ast_to_json5 = ast_to_json5;
exports.basic_offside_scanner = basic_offside_scanner;
exports.bind_context_scanner = bind_context_scanner;
exports.clike_context_scanners = clike_context_scanners;
exports.inject_dedent = inject_dedent;
exports.iter_ast_ndjson = iter_ast_ndjson;
exports.js_context_scanners = js_context_scanners;
exports.rx_indent = rx_indent;
exports.rx_indent_order = rx_indent_order;
exports.rx_lines = rx_lines;
exports.scan_clike = scan_clike;
exports.scan_javascript = scan_javascript;
exports.scan_offside_contexts = scan_offside_contexts;
exports.scanner_commentEOL = scanner_commentEOL;
exports.scanner_commentMultiLine = scanner_commentMultiLine;
exports.scanner_hashbangDirective = scanner_hashbangDirective;
exports.scanner_nestedSrc = scanner_nestedSrc;
exports.scanner_preprocessor = scanner_preprocessor;
exports.scanner_regexp = scanner_regexp;
exports.scanner_source = scanner_source;
exports.scanner_strDouble = scanner_strDouble;
exports.scanner_strSingle = scanner_strSingle;
exports.scanner_strTemplate = scanner_strTemplate;
//# sourceMappingURL=index.cjs.map
